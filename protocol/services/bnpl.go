package services

import (
    "context"
    "math/big"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"

    "github.com/optimus-boc-protocol/bindings"
)

// (removed bnplArrangementOutput and bnplManager interface â€“ service will
// use the generated binding directly.)

// BNPLService encapsulates interactions with the BNPLManager contract.
// It uses bindings generated by abigen.  The service holds a concrete
// *bindings.BNPLManager instance; tests can construct one against a
// simulated backend if desired.

type BNPLService struct {
    client bind.ContractBackend
    contract *bindings.BNPLManager
}

// NewBNPLServiceFromContract constructs a service from an existing
// contract instance.  Useful in tests where the caller deploys a contract
// on a simulated backend and wants to wrap it.
func NewBNPLServiceFromContract(client bind.ContractBackend, contract *bindings.BNPLManager) *BNPLService {
    return &BNPLService{client: client, contract: contract}
}

// NewBNPLService constructs a service given an eth client and contract address.
func NewBNPLService(rpcUrl, contractAddr string) (*BNPLService, error) {
    cli, err := ethclient.Dial(rpcUrl)
    if err != nil {
        return nil, err
    }
    addr := common.HexToAddress(contractAddr)
    c, err := bindings.NewBNPLManager(addr, cli)
    if err != nil {
        return nil, err
    }
    return &BNPLService{client: cli, contract: c}, nil
}

// BNPLArrangement mirrors the data returned by the contract's
// `getArrangement` view method.  This is copied from the generated
// binding so consumers don't have to deal with the anonymous struct.

type BNPLArrangement struct {
    ID                *big.Int
    DaoId             *big.Int
    Payer             common.Address
    Recipient         common.Address
    TotalAmount       *big.Int
    NumInstallments   *big.Int
    InstallmentAmounts []*big.Int
    StartTimestamp    *big.Int
    IntervalSeconds   *big.Int
    LateFeeBps        *big.Int
    Status            uint8
}

// GetArrangement retrieves an arrangement by ID using a read-only call.
// The returned struct is easier to work with than the anonymous type in the
// binding.
func (s *BNPLService) GetArrangement(ctx context.Context, id *big.Int) (BNPLArrangement, error) {
    out, err := s.contract.GetArrangement(&bind.CallOpts{Context: ctx}, id)
    if err != nil {
        return BNPLArrangement{}, err
    }
    return BNPLArrangement{
        ID: out.Id,
        DaoId: out.DaoId,
        Payer: out.Payer,
        Recipient: out.Recipient,
        TotalAmount: out.TotalAmount,
        NumInstallments: out.NumInstallments,
        InstallmentAmounts: out.InstallmentAmounts,
        StartTimestamp: out.StartTimestamp,
        IntervalSeconds: out.IntervalSeconds,
        LateFeeBps: out.LateFeeBps,
        Status: out.Status,
    }, nil
}

// CreateBNPL forwards a createBNPL call to the underlying contract.
// caller must supply a properly configured TransactOpts (e.g. with gas,
// signer, value if needed).  The returned transaction can be mined and
// its receipt inspected by the caller.
func (s *BNPLService) CreateBNPL(opts *bind.TransactOpts, daoId *big.Int, recipient common.Address, totalAmount *big.Int, startTimestamp *big.Int, intervalSeconds *big.Int, metadata []byte) (*types.Transaction, error) {
    return s.contract.CreateBNPL(opts, daoId, recipient, totalAmount, startTimestamp, intervalSeconds, metadata)
}

// MakePayment sends funds to the contract and marks an installment as paid.
func (s *BNPLService) MakePayment(opts *bind.TransactOpts, arrangementId *big.Int, installmentNumber uint8) (*types.Transaction, error) {
    return s.contract.MakePayment(opts, arrangementId, installmentNumber)
}

// ActivateBNPL triggers activation logic after a first payment has been
// verified on-chain.  It is idempotent.
func (s *BNPLService) ActivateBNPL(opts *bind.TransactOpts, arrangementId *big.Int) (*types.Transaction, error) {
    return s.contract.ActivateBNPL(opts, arrangementId)
}

// ApplyLateFee adds the configured late fee for a specific installment.
func (s *BNPLService) ApplyLateFee(opts *bind.TransactOpts, arrangementId *big.Int, installmentNumber uint8) (*types.Transaction, error) {
    return s.contract.ApplyLateFee(opts, arrangementId, installmentNumber)
}

// Reschedule updates the start/interval of an existing arrangement.  The
// caller must ensure authorization and policy compliance separately.
func (s *BNPLService) Reschedule(opts *bind.TransactOpts, arrangementId *big.Int, newStartTimestamp *big.Int, newIntervalSeconds *big.Int) (*types.Transaction, error) {
    return s.contract.Reschedule(opts, arrangementId, newStartTimestamp, newIntervalSeconds)
}
